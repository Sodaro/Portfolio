import{S as Te,i as $e,s as Ie,a as d,w as ye,L as Pe,h as t,c as p,x as ve,b as i,y as ge,f as _e,t as ke,z as xe,k as h,q as w,l as s,m as f,r as b,M as O,n as u,F as n,B as Ee}from"../../../../chunks/index-c3e420e7.js";import{B as je}from"../../../../chunks/Button-5c93f2dc.js";import{S as Be}from"../../../../chunks/SectionComponent-81cf6c8c.js";function ze(Q){let c,m,y,l,g,a,r,$,D,I,R,F,P,U,A,v,V,_,ae,X,k,ie,G,E,Y,W,j,Z,C,B,x,he,L,z,ee,J,H,te,K,S,oe,N,M,T,se;return{c(){c=h("h1"),m=w("Pumpkin boy"),y=d(),l=h("h2"),g=w("About"),a=d(),r=h("p"),$=w("Pumpkin Boy is a puzzle game where you play as a child that has been cursed by a witch, turning their head into a detachable pumpkin head. The character must throw their head to places the body can\u2019t reach, and move boxes around to weigh down pressure plates in order to escape a witch\u2019s dungeon. The game is a single-player game where the body and head are controlled by left-, and right-stick respectively."),D=d(),I=h("h2"),R=w("Implementation"),F=d(),P=h("h3"),U=w("Movement"),A=d(),v=h("p"),V=w(`The character\u2019s body has 1:1 movement without any kind of acceleration or drag and can walk up and down slopes. The head will collide with walls while attached, forcing the player to drop it to go through small gaps. While detached the player can move the head around, which is done by applying a force in the input direction. To have more control over the head movement and be able to stop easily, I added a velocity limiter and if there is no input given the velocity is quickly reduced until the head comes to a stop.
`),_=h("img"),X=d(),k=h("img"),G=d(),E=h("h3"),Y=w("Head Throw"),W=d(),j=h("p"),Z=w("To throw the head we start by enabling rigidbody properties (removing position/rotation constraints, enabling gravity, etc) unparent it from the body and then apply a force to it. The angle at which the head is thrown is based on the duration that the throw button is held, it starts at 0 and increases until a specified value (which we had set to 60 degrees in the build), after which it locks for a few seconds and then reverses back to 0. The line shows the trajectory the head will have in the air, and is calculated by using the projectile motion formula with an assumed air resistance of 0. Additional points were added to the line to show points beyond the starting height, and if the line were to intersect a collider it stops at the collision and the point is used as the final point for the line."),C=d(),B=h("p"),x=h("img"),L=d(),z=h("h3"),ee=w("Box Pushing"),J=d(),H=h("p"),te=w("We wanted to have boxes that could be pushed or pulled around, and that should physically behave like boxes (if sticking out over an edge they should start rotating and fall). The first iteration I did was to just apply a velocity to the box based on the player\u2019s movement and to lock the player from rotating while doing so. This sort of worked, but the box would tumble around when pushed as the friction of the ground would have an effect and small crevices and steps would sometimes cause the box to fly off."),K=d(),S=h("p"),oe=w("The solution I used, in the end, was to lock the player movement, turn off gravity and make the box kinematic, and then move the box based on the character movement and the initial offset the box had to the player when it was grabbed. To prevent the player from placing the box inside walls I checked for box collisions from the character using the size of the box and the velocity of the player, and if the box \u201Cwould overlap something\u201D I set the velocity of the player to zero."),N=d(),M=h("p"),T=h("img"),this.h()},l(e){c=s(e,"H1",{});var o=f(c);m=b(o,"Pumpkin boy"),o.forEach(t),y=p(e),l=s(e,"H2",{});var ne=f(l);g=b(ne,"About"),ne.forEach(t),a=p(e),r=s(e,"P",{});var le=f(r);$=b(le,"Pumpkin Boy is a puzzle game where you play as a child that has been cursed by a witch, turning their head into a detachable pumpkin head. The character must throw their head to places the body can\u2019t reach, and move boxes around to weigh down pressure plates in order to escape a witch\u2019s dungeon. The game is a single-player game where the body and head are controlled by left-, and right-stick respectively."),le.forEach(t),D=p(e),I=s(e,"H2",{});var re=f(I);R=b(re,"Implementation"),re.forEach(t),F=p(e),P=s(e,"H3",{});var de=f(P);U=b(de,"Movement"),de.forEach(t),A=p(e),v=s(e,"P",{});var q=f(v);V=b(q,`The character\u2019s body has 1:1 movement without any kind of acceleration or drag and can walk up and down slopes. The head will collide with walls while attached, forcing the player to drop it to go through small gaps. While detached the player can move the head around, which is done by applying a force in the input direction. To have more control over the head movement and be able to stop easily, I added a velocity limiter and if there is no input given the velocity is quickly reduced until the head comes to a stop.
`),_=s(q,"IMG",{src:!0,alt:!0,title:!0}),X=p(q),k=s(q,"IMG",{src:!0,alt:!0,title:!0}),q.forEach(t),G=p(e),E=s(e,"H3",{});var pe=f(E);Y=b(pe,"Head Throw"),pe.forEach(t),W=p(e),j=s(e,"P",{});var ce=f(j);Z=b(ce,"To throw the head we start by enabling rigidbody properties (removing position/rotation constraints, enabling gravity, etc) unparent it from the body and then apply a force to it. The angle at which the head is thrown is based on the duration that the throw button is held, it starts at 0 and increases until a specified value (which we had set to 60 degrees in the build), after which it locks for a few seconds and then reverses back to 0. The line shows the trajectory the head will have in the air, and is calculated by using the projectile motion formula with an assumed air resistance of 0. Additional points were added to the line to show points beyond the starting height, and if the line were to intersect a collider it stops at the collision and the point is used as the final point for the line."),ce.forEach(t),C=p(e),B=s(e,"P",{});var fe=f(B);x=s(fe,"IMG",{src:!0,alt:!0,title:!0}),fe.forEach(t),L=p(e),z=s(e,"H3",{});var ue=f(z);ee=b(ue,"Box Pushing"),ue.forEach(t),J=p(e),H=s(e,"P",{});var me=f(H);te=b(me,"We wanted to have boxes that could be pushed or pulled around, and that should physically behave like boxes (if sticking out over an edge they should start rotating and fall). The first iteration I did was to just apply a velocity to the box based on the player\u2019s movement and to lock the player from rotating while doing so. This sort of worked, but the box would tumble around when pushed as the friction of the ground would have an effect and small crevices and steps would sometimes cause the box to fly off."),me.forEach(t),K=p(e),S=s(e,"P",{});var we=f(S);oe=b(we,"The solution I used, in the end, was to lock the player movement, turn off gravity and make the box kinematic, and then move the box based on the character movement and the initial offset the box had to the player when it was grabbed. To prevent the player from placing the box inside walls I checked for box collisions from the character using the size of the box and the velocity of the player, and if the box \u201Cwould overlap something\u201D I set the velocity of the player to zero."),we.forEach(t),N=p(e),M=s(e,"P",{});var be=f(M);T=s(be,"IMG",{src:!0,alt:!0,title:!0}),be.forEach(t),this.h()},h(){O(_.src,ae="/projectmedia/pumpkin/body_head.png")||u(_,"src",ae),u(_,"alt","FStack view of the hide/show bar frames"),u(_,"title","Displaying the two frames used for hiding/showing the right actionbar."),O(k.src,ie="/projectmedia/pumpkin/body_nohead.png")||u(k,"src",ie),u(k,"alt","FStack view of the hide/show bar frames"),u(k,"title","Displaying the two frames used for hiding/showing the right actionbar."),O(x.src,he="/projectmedia/pumpkin/throw_text.png")||u(x,"src",he),u(x,"alt","FStack view of the hide/show bar frames"),u(x,"title","Displaying the two frames used for hiding/showing the right actionbar."),O(T.src,se="/projectmedia/pumpkin/box_push.png")||u(T,"src",se),u(T,"alt","FStack view of the hide/show bar frames"),u(T,"title","Displaying the two frames used for hiding/showing the right actionbar.")},m(e,o){i(e,c,o),n(c,m),i(e,y,o),i(e,l,o),n(l,g),i(e,a,o),i(e,r,o),n(r,$),i(e,D,o),i(e,I,o),n(I,R),i(e,F,o),i(e,P,o),n(P,U),i(e,A,o),i(e,v,o),n(v,V),n(v,_),n(v,X),n(v,k),i(e,G,o),i(e,E,o),n(E,Y),i(e,W,o),i(e,j,o),n(j,Z),i(e,C,o),i(e,B,o),n(B,x),i(e,L,o),i(e,z,o),n(z,ee),i(e,J,o),i(e,H,o),n(H,te),i(e,K,o),i(e,S,o),n(S,oe),i(e,N,o),i(e,M,o),n(M,T)},p:Ee,d(e){e&&t(c),e&&t(y),e&&t(l),e&&t(a),e&&t(r),e&&t(D),e&&t(I),e&&t(F),e&&t(P),e&&t(A),e&&t(v),e&&t(G),e&&t(E),e&&t(W),e&&t(j),e&&t(C),e&&t(B),e&&t(L),e&&t(z),e&&t(J),e&&t(H),e&&t(K),e&&t(S),e&&t(N),e&&t(M)}}}function He(Q){let c,m,y,l,g;return m=new je({props:{href:"/"}}),l=new Be({props:{$$slots:{default:[ze]},$$scope:{ctx:Q}}}),{c(){c=d(),ye(m.$$.fragment),y=d(),ye(l.$$.fragment),this.h()},l(a){Pe("svelte-vudgef",document.head).forEach(t),c=p(a),ve(m.$$.fragment,a),y=p(a),ve(l.$$.fragment,a),this.h()},h(){document.title="DavidB | Pumpkin Boy"},m(a,r){i(a,c,r),ge(m,a,r),i(a,y,r),ge(l,a,r),g=!0},p(a,[r]){const $={};r&1&&($.$$scope={dirty:r,ctx:a}),l.$set($)},i(a){g||(_e(m.$$.fragment,a),_e(l.$$.fragment,a),g=!0)},o(a){ke(m.$$.fragment,a),ke(l.$$.fragment,a),g=!1},d(a){a&&t(c),xe(m,a),a&&t(y),xe(l,a)}}}const De={title:"Pumpkin Boy",date:"2022-07-02",thumb:"pumpkinboy.png",pos:"center",lang:"c#"};class Fe extends Te{constructor(c){super(),$e(this,c,null,He,Ie,{})}}export{Fe as default,De as metadata};
