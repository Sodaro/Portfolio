import{S as Ln,i as xn,s as Rn,k as c,l as i,m as r,h as a,n as Un,b as u,B as nn,a as k,w as L,L as ks,c as h,x,y as R,f as W,t as T,z as C,q as f,r as m,F as t}from"../../../../chunks/index-c3e420e7.js";import{B as jn,M as hs,C as An}from"../../../../chunks/ButtonLink-a66981e6.js";import{B as fs}from"../../../../chunks/Button-5c93f2dc.js";import{S as ms}from"../../../../chunks/SectionComponent-81cf6c8c.js";function ds(w){let s,p=`<code class="language-cpp"><span class="token function">USTRUCT</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">struct</span> <span class="token class-name">FEnigmaComponents</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditInstanceOnly<span class="token punctuation">)</span>
	AMachineLamp<span class="token operator">*</span> Lamp<span class="token punctuation">;</span>
	<span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditInstanceOnly<span class="token punctuation">)</span>
	AMachineKey<span class="token operator">*</span> Key<span class="token punctuation">;</span>
	<span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditInstanceOnly<span class="token punctuation">)</span>
	AMachinePort<span class="token operator">*</span> Port<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code>`;return{c(){s=c("pre"),this.h()},l(e){s=i(e,"PRE",{class:!0});var l=r(s);l.forEach(a),this.h()},h(){Un(s,"class","language-cpp")},m(e,l){u(e,s,l),s.innerHTML=p},p:nn,i:nn,o:nn,d(e){e&&a(s)}}}class $s extends Ln{constructor(s){super(),xn(this,s,null,ds,Rn,{})}}function ws(w){let s,p=`<code class="language-cpp">NewAlphabetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
InputLetter <span class="token operator">=</span> Alphabet<span class="token punctuation">[</span>Input<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>reverse <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	Index <span class="token operator">=</span> Input <span class="token operator">+</span> CurrentRotationOffset <span class="token operator">-</span> RingSettingOffset<span class="token punctuation">;</span>
	<span class="token function">Wrap</span><span class="token punctuation">(</span>Index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	CipherLetter <span class="token operator">=</span> CipherArr<span class="token punctuation">[</span>Index<span class="token punctuation">]</span><span class="token punctuation">;</span>
	NewAlphabetIndex <span class="token operator">=</span> CipherLetter <span class="token operator">-</span> <span class="token char">'A'</span> <span class="token operator">-</span> CurrentRotationOffset <span class="token operator">+</span> RingSettingOffset<span class="token punctuation">;</span>
	<span class="token function">Wrap</span><span class="token punctuation">(</span>NewAlphabetIndex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>reverse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	Index <span class="token operator">=</span> Input <span class="token operator">+</span> CurrentRotationOffset <span class="token operator">-</span> RingSettingOffset<span class="token punctuation">;</span>
	<span class="token function">Wrap</span><span class="token punctuation">(</span>Index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>CipherArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span> <span class="token operator">==</span> Index<span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			NewAlphabetIndex <span class="token operator">=</span> i <span class="token operator">-</span> CurrentRotationOffset <span class="token operator">+</span> RingSettingOffset<span class="token punctuation">;</span>
			<span class="token function">Wrap</span><span class="token punctuation">(</span>NewAlphabetIndex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">return</span> NewAlphabetIndex<span class="token punctuation">;</span></code>`;return{c(){s=c("pre"),this.h()},l(e){s=i(e,"PRE",{class:!0});var l=r(s);l.forEach(a),this.h()},h(){Un(s,"class","language-cpp")},m(e,l){u(e,s,l),s.innerHTML=p},p:nn,i:nn,o:nn,d(e){e&&a(s)}}}class gs extends Ln{constructor(s){super(),xn(this,s,null,ws,Rn,{})}}function bs(w){let s,p=`<code class="language-cpp">int32 <span class="token class-name">AEnigmaMachine</span><span class="token double-colon punctuation">::</span><span class="token function">EncodeLetter</span><span class="token punctuation">(</span>int32 AlphabetIndex<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">/*
	* ENCRYPTION LOGIC
	* 1. Rotate first wheel every time a key is pressed.
	* 2. Go through plugboard (Check if the letter port is connected to another port if so replace letter)
	* 3. Encrypt the input based on each wheel's configs.
	* 4. Get the connected letter in the reflector.
	* 5. Reverse through the wheels. 
		(different encryption to simulate the electric signal going the opposite way)
	* 6. Go through plugboard again
	* 7. Turn on the lamp matching the encrypted key, and output it to the onscreen textwidget.
	*/</span>

	RotorWheels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span><span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	FString Key <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	Key<span class="token punctuation">.</span><span class="token function">AppendChar</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span>AlphabetIndex <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	TWeakObjectPtr<span class="token operator">&lt;</span>AMachinePort<span class="token operator">></span> Port <span class="token operator">=</span> LetterComponents<span class="token punctuation">[</span>Key<span class="token punctuation">]</span><span class="token punctuation">.</span>Port<span class="token operator">-></span><span class="token function">GetSwappedPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Port <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		AlphabetIndex <span class="token operator">=</span> Port<span class="token operator">-></span><span class="token function">GetLetterIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	TCHAR Letter<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		AlphabetIndex <span class="token operator">=</span> RotorWheels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span><span class="token function">Encode</span><span class="token punctuation">(</span>AlphabetIndex<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Letter <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span>AlphabetIndex <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	AlphabetIndex <span class="token operator">=</span> ReflectorWheel<span class="token operator">-></span><span class="token function">Encode</span><span class="token punctuation">(</span>AlphabetIndex<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Letter <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span>AlphabetIndex <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		AlphabetIndex <span class="token operator">=</span> RotorWheels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span><span class="token function">Encode</span><span class="token punctuation">(</span>AlphabetIndex<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Letter <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span>AlphabetIndex <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	Key <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	Key<span class="token punctuation">.</span><span class="token function">AppendChar</span><span class="token punctuation">(</span>Letter<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Port <span class="token operator">=</span> LetterComponents<span class="token punctuation">[</span>Key<span class="token punctuation">]</span><span class="token punctuation">.</span>Port<span class="token operator">-></span><span class="token function">GetSwappedPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Port <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		AlphabetIndex <span class="token operator">=</span> Port<span class="token operator">-></span><span class="token function">GetLetterIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Letter <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">(</span>AlphabetIndex <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>LastLampKey <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		LetterComponents<span class="token punctuation">[</span>LastLampKey<span class="token punctuation">]</span><span class="token punctuation">.</span>Lamp<span class="token operator">-></span><span class="token function">TurnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	LastLampKey<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	LastLampKey <span class="token operator">=</span> LastLampKey<span class="token punctuation">.</span><span class="token function">AppendChar</span><span class="token punctuation">(</span>Letter<span class="token punctuation">)</span><span class="token punctuation">;</span>
	LetterComponents<span class="token punctuation">[</span>LastLampKey<span class="token punctuation">]</span><span class="token punctuation">.</span>Lamp<span class="token operator">-></span><span class="token function">TurnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	FString ReadableText <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	OutputText <span class="token operator">+=</span> Letter<span class="token punctuation">;</span>
	ReadableText <span class="token operator">+=</span> OutputText<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> OutputText<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			ReadableText <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>

		ReadableText <span class="token operator">+=</span> OutputText<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	OutputWidget<span class="token operator">-></span><span class="token function">SetText</span><span class="token punctuation">(</span>ReadableText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code>`;return{c(){s=c("pre"),this.h()},l(e){s=i(e,"PRE",{class:!0});var l=r(s);l.forEach(a),this.h()},h(){Un(s,"class","language-cpp")},m(e,l){u(e,s,l),s.innerHTML=p},p:nn,i:nn,o:nn,d(e){e&&a(s)}}}class _s extends Ln{constructor(s){super(),xn(this,s,null,bs,Rn,{})}}function ys(w){let s;return{c(){s=f("Emulator")},l(p){s=m(p,"Emulator")},m(p,e){u(p,s,e)},d(p){p&&a(s)}}}function vs(w){let s;return{c(){s=f("Article")},l(p){s=m(p,"Article")},m(p,e){u(p,s,e)},d(p){p&&a(s)}}}function Es(w){let s;return{c(){s=f("Wikipedia page")},l(p){s=m(p,"Wikipedia page")},m(p,e){u(p,s,e)},d(p){p&&a(s)}}}function Is(w){let s,p,e,l,y,d,g,P,ln,S,F,O,cn,v,rn,j,sn,un,U,an,kn,G,q,Y,$n,X,B,hn,A,wn,Z,z,fn,b,E,mn,M,V,K,dn,n,o,tn,D,en,pn,H,on,N,Wn,In,I,bn,Tn,Cn,_n,Pn,Sn,yn,On,Bn,vn,Mn,Kn,gn,Hn,En,Gn;return{c(){s=c("ul"),p=c("li"),e=f("1. A is pressed"),l=k(),y=c("li"),d=f("2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),g=k(),P=c("li"),ln=f("3. Wheel 1 receives A and outputs C"),S=k(),F=c("li"),O=f("4. Wheel 2 receives C and outputs D"),cn=k(),v=c("li"),rn=f("5. Wheel 3 receives D and outputs F"),j=k(),sn=c("li"),un=f("6. Reflector receives F and outputs S"),U=k(),an=c("li"),kn=f("7. Wheel 3 receives S and outputs S"),G=k(),q=c("li"),Y=f("8. Wheel 2 receives S and outputs E"),$n=k(),X=c("li"),B=f("9. Wheel 1 receives E and outputs B"),hn=k(),A=c("li"),wn=f("10. "),Z=c("strong"),z=f("Lamp with letter B lights up"),fn=k(),b=c("ul"),E=c("li"),mn=f("1. A is pressed"),M=k(),V=c("li"),K=f("2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),dn=k(),n=c("li"),o=f("3. Wheel 1 receives A and outputs D"),tn=k(),D=c("li"),en=f("4. \u2026"),pn=k(),H=c("li"),on=f("10. "),N=c("strong"),Wn=f("Lamp with letter D lights up"),In=k(),I=c("ul"),bn=c("li"),Tn=f("1. A is pressed"),Cn=k(),_n=c("li"),Pn=f("2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),Sn=k(),yn=c("li"),On=f("3. Wheel 1 receives A and outputs E"),Bn=k(),vn=c("li"),Mn=f("4. \u2026"),Kn=k(),gn=c("li"),Hn=f("10. "),En=c("strong"),Gn=f("Lamp with letter Z lights up")},l(_){s=i(_,"UL",{});var $=r(s);p=i($,"LI",{});var qn=r(p);e=m(qn,"1. A is pressed"),qn.forEach(a),l=h($),y=i($,"LI",{});var Yn=r(y);d=m(Yn,"2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),Yn.forEach(a),g=h($),P=i($,"LI",{});var Xn=r(P);ln=m(Xn,"3. Wheel 1 receives A and outputs C"),Xn.forEach(a),S=h($),F=i($,"LI",{});var Zn=r(F);O=m(Zn,"4. Wheel 2 receives C and outputs D"),Zn.forEach(a),cn=h($),v=i($,"LI",{});var zn=r(v);rn=m(zn,"5. Wheel 3 receives D and outputs F"),zn.forEach(a),j=h($),sn=i($,"LI",{});var Vn=r(sn);un=m(Vn,"6. Reflector receives F and outputs S"),Vn.forEach(a),U=h($),an=i($,"LI",{});var Jn=r(an);kn=m(Jn,"7. Wheel 3 receives S and outputs S"),Jn.forEach(a),G=h($),q=i($,"LI",{});var Qn=r(q);Y=m(Qn,"8. Wheel 2 receives S and outputs E"),Qn.forEach(a),$n=h($),X=i($,"LI",{});var ns=r(X);B=m(ns,"9. Wheel 1 receives E and outputs B"),ns.forEach(a),hn=h($),A=i($,"LI",{});var Dn=r(A);wn=m(Dn,"10. "),Z=i(Dn,"STRONG",{});var ss=r(Z);z=m(ss,"Lamp with letter B lights up"),ss.forEach(a),Dn.forEach(a),$.forEach(a),fn=h(_),b=i(_,"UL",{});var J=r(b);E=i(J,"LI",{});var as=r(E);mn=m(as,"1. A is pressed"),as.forEach(a),M=h(J),V=i(J,"LI",{});var ts=r(V);K=m(ts,"2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),ts.forEach(a),dn=h(J),n=i(J,"LI",{});var es=r(n);o=m(es,"3. Wheel 1 receives A and outputs D"),es.forEach(a),tn=h(J),D=i(J,"LI",{});var ps=r(D);en=m(ps,"4. \u2026"),ps.forEach(a),pn=h(J),H=i(J,"LI",{});var Nn=r(H);on=m(Nn,"10. "),N=i(Nn,"STRONG",{});var os=r(N);Wn=m(os,"Lamp with letter D lights up"),os.forEach(a),Nn.forEach(a),J.forEach(a),In=h(_),I=i(_,"UL",{});var Q=r(I);bn=i(Q,"LI",{});var ls=r(bn);Tn=m(ls,"1. A is pressed"),ls.forEach(a),Cn=h(Q),_n=i(Q,"LI",{});var cs=r(_n);Pn=m(cs,"2. Wheel 1 rotates and a signal is sent from the keyboard to Wheel 1"),cs.forEach(a),Sn=h(Q),yn=i(Q,"LI",{});var is=r(yn);On=m(is,"3. Wheel 1 receives A and outputs E"),is.forEach(a),Bn=h(Q),vn=i(Q,"LI",{});var rs=r(vn);Mn=m(rs,"4. \u2026"),rs.forEach(a),Kn=h(Q),gn=i(Q,"LI",{});var Fn=r(gn);Hn=m(Fn,"10. "),En=i(Fn,"STRONG",{});var us=r(En);Gn=m(us,"Lamp with letter Z lights up"),us.forEach(a),Fn.forEach(a),Q.forEach(a)},m(_,$){u(_,s,$),t(s,p),t(p,e),t(s,l),t(s,y),t(y,d),t(s,g),t(s,P),t(P,ln),t(s,S),t(s,F),t(F,O),t(s,cn),t(s,v),t(v,rn),t(s,j),t(s,sn),t(sn,un),t(s,U),t(s,an),t(an,kn),t(s,G),t(s,q),t(q,Y),t(s,$n),t(s,X),t(X,B),t(s,hn),t(s,A),t(A,wn),t(A,Z),t(Z,z),u(_,fn,$),u(_,b,$),t(b,E),t(E,mn),t(b,M),t(b,V),t(V,K),t(b,dn),t(b,n),t(n,o),t(b,tn),t(b,D),t(D,en),t(b,pn),t(b,H),t(H,on),t(H,N),t(N,Wn),u(_,In,$),u(_,I,$),t(I,bn),t(bn,Tn),t(I,Cn),t(I,_n),t(_n,Pn),t(I,Sn),t(I,yn),t(yn,On),t(I,Bn),t(I,vn),t(vn,Mn),t(I,Kn),t(I,gn),t(gn,Hn),t(gn,En),t(En,Gn)},p:nn,d(_){_&&a(s),_&&a(fn),_&&a(b),_&&a(In),_&&a(I)}}}function As(w){let s,p;return s=new $s({}),{c(){L(s.$$.fragment)},l(e){x(s.$$.fragment,e)},m(e,l){R(s,e,l),p=!0},i(e){p||(W(s.$$.fragment,e),p=!0)},o(e){T(s.$$.fragment,e),p=!1},d(e){C(s,e)}}}function Ls(w){let s,p;return s=new gs({}),{c(){L(s.$$.fragment)},l(e){x(s.$$.fragment,e)},m(e,l){R(s,e,l),p=!0},i(e){p||(W(s.$$.fragment,e),p=!0)},o(e){T(s.$$.fragment,e),p=!1},d(e){C(s,e)}}}function xs(w){let s,p;return s=new _s({}),{c(){L(s.$$.fragment)},l(e){x(s.$$.fragment,e)},m(e,l){R(s,e,l),p=!0},i(e){p||(W(s.$$.fragment,e),p=!0)},o(e){T(s.$$.fragment,e),p=!1},d(e){C(s,e)}}}function Rs(w){let s,p,e,l,y,d,g,P,ln,S,F,O,cn,v,rn,j,sn,un,U,an,kn,G,q,Y,$n,X,B,hn,A,wn,Z,z,fn,b,E,mn,M,V,K,dn;return S=new jn({props:{href:"https://www.101computing.net/enigma-machine-emulator/",$$slots:{default:[ys]},$$scope:{ctx:w}}}),O=new jn({props:{href:"https://www.ciphermachinesandcryptology.com/en/enigmatech.htm",$$slots:{default:[vs]},$$scope:{ctx:w}}}),v=new jn({props:{href:"https://en.wikipedia.org/wiki/Enigma_rotor_details",$$slots:{default:[Es]},$$scope:{ctx:w}}}),G=new hs({props:{width:"640",height:"360",src:"/projectmedia/enigmamachine_rotorwheel.mp4",alt:"a video showing a breakdown of a rotor, first showing the rotor plugs and wires rotating and then showing the wiring rotating separately "}}),B=new An({props:{title:"Encryption Example",$$slots:{default:[Is]},$$scope:{ctx:w}}}),E=new An({props:{title:"EnigmaComponents Struct Snippet",$$slots:{default:[As]},$$scope:{ctx:w}}}),M=new An({props:{title:"Individual Rotor Encryption Snippet",$$slots:{default:[Ls]},$$scope:{ctx:w}}}),K=new An({props:{title:"Machine Encryption Snippet",$$slots:{default:[xs]},$$scope:{ctx:w}}}),{c(){s=c("h1"),p=f("Enigma Machine Project"),e=k(),l=c("h2"),y=f("Background"),d=k(),g=c("p"),P=f("I got the inspiration to make an Enigma Machine after seeing the movie \u201CThe Imitation Game\u201D and watching a few Computerphile youtube-videos that talked about how the machine worked and how it was cracked. My goal with the project was to make a machine that had rotors you could manually rotate and swap out for different configs and to have a working lampboard that shows the encrypted letter. I did not look at any existing algorithms, instead, I limited myself to the following resources:"),ln=k(),L(S.$$.fragment),F=k(),L(O.$$.fragment),cn=k(),L(v.$$.fragment),rn=k(),j=c("h2"),sn=f("How it works"),un=k(),U=c("p"),an=f("A typical machine has an input board, plugboard, lampboard, three RotorWheels, and a reflector. The rotor wheels have unique configs but they behave like rotating substitution ciphers, so RotorWheel I in position 0 might take an A as input and output it as K, whereas another wheel might output the same as X. The wheels can be placed in any of the three positions, and the initial rotation offset and ring setting (which shifts the wiring around) can also be changed."),kn=k(),L(G.$$.fragment),q=k(),Y=c("p"),$n=f("The first wheel rotates every time a key is pressed, and when it reaches a so-called \u201Cturnover notch position\u201D it will rotate the next wheel, which in turn will rotate the last wheel when it reaches its own turnover position, similarly to an odometer. The rotation behaves like an index offset, which makes it so pressing the same key multiple times won\u2019t output the same letter multiple times in a row. At the end of the machine, there is a \u201Creflector\u201D that has pairs of letters mapped together (where a regular wheel would map A to B but not have B mapped to A, the reflector maps A to B and B to A)."),X=k(),L(B.$$.fragment),hn=k(),A=c("h2"),wn=f("Implementation"),Z=k(),z=c("p"),fn=f(`For easy access and quick access to the interactable input key objects, lamps, and plugboard ports I chose to use a hashmap with structs.
I simulate the rotation of the wheels by incrementing an index offset, and the ring setting with a different offset which I use to change what letter gets returned by the encryption.
When a key is pressed I call EncodeLetter with the alphabet position of the letter as the parameter.`),b=k(),L(E.$$.fragment),mn=k(),L(M.$$.fragment),V=k(),L(K.$$.fragment)},l(n){s=i(n,"H1",{});var o=r(s);p=m(o,"Enigma Machine Project"),o.forEach(a),e=h(n),l=i(n,"H2",{});var tn=r(l);y=m(tn,"Background"),tn.forEach(a),d=h(n),g=i(n,"P",{});var D=r(g);P=m(D,"I got the inspiration to make an Enigma Machine after seeing the movie \u201CThe Imitation Game\u201D and watching a few Computerphile youtube-videos that talked about how the machine worked and how it was cracked. My goal with the project was to make a machine that had rotors you could manually rotate and swap out for different configs and to have a working lampboard that shows the encrypted letter. I did not look at any existing algorithms, instead, I limited myself to the following resources:"),D.forEach(a),ln=h(n),x(S.$$.fragment,n),F=h(n),x(O.$$.fragment,n),cn=h(n),x(v.$$.fragment,n),rn=h(n),j=i(n,"H2",{});var en=r(j);sn=m(en,"How it works"),en.forEach(a),un=h(n),U=i(n,"P",{});var pn=r(U);an=m(pn,"A typical machine has an input board, plugboard, lampboard, three RotorWheels, and a reflector. The rotor wheels have unique configs but they behave like rotating substitution ciphers, so RotorWheel I in position 0 might take an A as input and output it as K, whereas another wheel might output the same as X. The wheels can be placed in any of the three positions, and the initial rotation offset and ring setting (which shifts the wiring around) can also be changed."),pn.forEach(a),kn=h(n),x(G.$$.fragment,n),q=h(n),Y=i(n,"P",{});var H=r(Y);$n=m(H,"The first wheel rotates every time a key is pressed, and when it reaches a so-called \u201Cturnover notch position\u201D it will rotate the next wheel, which in turn will rotate the last wheel when it reaches its own turnover position, similarly to an odometer. The rotation behaves like an index offset, which makes it so pressing the same key multiple times won\u2019t output the same letter multiple times in a row. At the end of the machine, there is a \u201Creflector\u201D that has pairs of letters mapped together (where a regular wheel would map A to B but not have B mapped to A, the reflector maps A to B and B to A)."),H.forEach(a),X=h(n),x(B.$$.fragment,n),hn=h(n),A=i(n,"H2",{});var on=r(A);wn=m(on,"Implementation"),on.forEach(a),Z=h(n),z=i(n,"P",{});var N=r(z);fn=m(N,`For easy access and quick access to the interactable input key objects, lamps, and plugboard ports I chose to use a hashmap with structs.
I simulate the rotation of the wheels by incrementing an index offset, and the ring setting with a different offset which I use to change what letter gets returned by the encryption.
When a key is pressed I call EncodeLetter with the alphabet position of the letter as the parameter.`),N.forEach(a),b=h(n),x(E.$$.fragment,n),mn=h(n),x(M.$$.fragment,n),V=h(n),x(K.$$.fragment,n)},m(n,o){u(n,s,o),t(s,p),u(n,e,o),u(n,l,o),t(l,y),u(n,d,o),u(n,g,o),t(g,P),u(n,ln,o),R(S,n,o),u(n,F,o),R(O,n,o),u(n,cn,o),R(v,n,o),u(n,rn,o),u(n,j,o),t(j,sn),u(n,un,o),u(n,U,o),t(U,an),u(n,kn,o),R(G,n,o),u(n,q,o),u(n,Y,o),t(Y,$n),u(n,X,o),R(B,n,o),u(n,hn,o),u(n,A,o),t(A,wn),u(n,Z,o),u(n,z,o),t(z,fn),u(n,b,o),R(E,n,o),u(n,mn,o),R(M,n,o),u(n,V,o),R(K,n,o),dn=!0},p(n,o){const tn={};o&1&&(tn.$$scope={dirty:o,ctx:n}),S.$set(tn);const D={};o&1&&(D.$$scope={dirty:o,ctx:n}),O.$set(D);const en={};o&1&&(en.$$scope={dirty:o,ctx:n}),v.$set(en);const pn={};o&1&&(pn.$$scope={dirty:o,ctx:n}),B.$set(pn);const H={};o&1&&(H.$$scope={dirty:o,ctx:n}),E.$set(H);const on={};o&1&&(on.$$scope={dirty:o,ctx:n}),M.$set(on);const N={};o&1&&(N.$$scope={dirty:o,ctx:n}),K.$set(N)},i(n){dn||(W(S.$$.fragment,n),W(O.$$.fragment,n),W(v.$$.fragment,n),W(G.$$.fragment,n),W(B.$$.fragment,n),W(E.$$.fragment,n),W(M.$$.fragment,n),W(K.$$.fragment,n),dn=!0)},o(n){T(S.$$.fragment,n),T(O.$$.fragment,n),T(v.$$.fragment,n),T(G.$$.fragment,n),T(B.$$.fragment,n),T(E.$$.fragment,n),T(M.$$.fragment,n),T(K.$$.fragment,n),dn=!1},d(n){n&&a(s),n&&a(e),n&&a(l),n&&a(d),n&&a(g),n&&a(ln),C(S,n),n&&a(F),C(O,n),n&&a(cn),C(v,n),n&&a(rn),n&&a(j),n&&a(un),n&&a(U),n&&a(kn),C(G,n),n&&a(q),n&&a(Y),n&&a(X),C(B,n),n&&a(hn),n&&a(A),n&&a(Z),n&&a(z),n&&a(b),C(E,n),n&&a(mn),C(M,n),n&&a(V),C(K,n)}}}function Ws(w){let s,p,e,l,y;return p=new fs({props:{href:"/"}}),l=new ms({props:{$$slots:{default:[Rs]},$$scope:{ctx:w}}}),{c(){s=k(),L(p.$$.fragment),e=k(),L(l.$$.fragment),this.h()},l(d){ks("svelte-sgbnlp",document.head).forEach(a),s=h(d),x(p.$$.fragment,d),e=h(d),x(l.$$.fragment,d),this.h()},h(){document.title="DavidB | Enigma Machine"},m(d,g){u(d,s,g),R(p,d,g),u(d,e,g),R(l,d,g),y=!0},p(d,[g]){const P={};g&1&&(P.$$scope={dirty:g,ctx:d}),l.$set(P)},i(d){y||(W(p.$$.fragment,d),W(l.$$.fragment,d),y=!0)},o(d){T(p.$$.fragment,d),T(l.$$.fragment,d),y=!1},d(d){d&&a(s),C(p,d),d&&a(e),C(l,d)}}}const Os={title:"Enigma Machine",date:"2022-07-03",thumb:"enigmamachine.png",pos:"center",lang:"c++"};class Bs extends Ln{constructor(s){super(),xn(this,s,null,Ws,Rn,{})}}export{Bs as default,Os as metadata};
